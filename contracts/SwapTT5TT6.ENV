// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
pragma abicoder v2;

import '@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@uniswap/universal-router/contracts/interfaces/IUniversalRouter.sol';

contract SwapTT5TT6 {
    address public constant UNIVERSAL_ROUTER = 0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2;
    address public constant TT5 = 0x1Bc0330e6922DE94Ac2D1e448d675F7a2f001AAD;
    address public constant TT6 = 0xD8393be00FE996F518C7b768333E74F3034C746D;
    address public constant QUOTER_V2 = 0x61fFE014bA17989E743c5F6cB21bF9697530B21e;

    uint24 private constant POOL_FEE = 3000; // Assuming 0.3% fee, adjust if different

    event QuoteReceived(uint256 amountOut);
    event SwapExecuted(uint256 amountIn, uint256 amountOut);

    function swapTT5TT6(uint256 tt5Amount, bytes calldata universalRouterCalldata) external {
        require(tt5Amount > 0, "Amount must be greater than 0");
        require(IERC20(TT5).balanceOf(msg.sender) >= tt5Amount, "Insufficient TT5 balance");

        IERC20(TT5).transferFrom(msg.sender, address(this), tt5Amount);
        IERC20(TT5).approve(UNIVERSAL_ROUTER, tt5Amount);

        (bool success, ) = UNIVERSAL_ROUTER.call(universalRouterCalldata);
        require(success, "Universal Router execution failed");

        uint256 tt6Received = IERC20(TT6).balanceOf(address(this));
        IERC20(TT6).transfer(msg.sender, tt6Received);

        emit SwapExecuted(tt5Amount, tt6Received);
    }
}
 